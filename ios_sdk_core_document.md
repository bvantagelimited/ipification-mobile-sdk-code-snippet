# iOS SDK 

This document describes the IPification iOS SDK and its usage. The main purpose of the SDK is to provide network-based authentication for mobile users.


Main Flow of iOS SDK : 
*   Prepare the `authorization request` with required parameters
*   Call Authorization API with `authorization request` ( GET ) through `Cellular Network` (use Network Framework - NetworkSocket.swift)
*   Receive a response with: 
    *   result directly via `redirect_uri` (1) or 
    *   redirection url (`301` or `302`) (2)
*   (1) -> Parser the response then return the result to client
*   (2) -> Perform all url(s) redirection until receive the result with `redirect_uri` (through `Cellular Network`)

**Note:** All requests need to be performed via `cellular network` interface.


## Authorization Request (HTTP)

```
GET https://api.ipification.com/auth/realms/ipification/protocol/openid-connect/auth?
response_type=code&
client_id={client-id}&
redirect_uri={client-callback-uri}&
scope=openid ip:phone_verify&
state={state}&
login_hint={login_hint}
-------
Response: 
(1) 200 - redirect_uri?code=abcxyz&state={state}
(2) 302 - url redirection (ex: https://mnv.telco.com/webhook/api/webhook/auth?state=xyzabc)
```

##### Parameters:
|     Name     | Description |
| ------------- | ------------- |
| client_id | unique identifier of the client that is generated by IPification and provided to client during the onboarding process. |
| redirect_uri |  is used when redirecting a user back to the client application. During the onboarding process, the client's `redirect_uri` will be provided, this value can represent wildcard uri and will be used to validate provided `redirect_uri` in the request. Redirect URI must be same accross all requestst in a flow. |
| scope | use `openid ip:phone_verify` for phone number verifying  |
| login_hint | end-user phone number (MSISDN).Phone number should be specified according to the E.164 number formatting (http://en.wikipedia.org/wiki/E.164) without leading + sign. |
|mcc (optional) | Mobile Country Code |
|mnc (optional) | Mobile Network Code |
| consent_id (optional) | Unique ID for the consent that is traceable if consent audit is required. Value will be provided if needed in integration process. |
| consent_timestamp (optional) | The time stamp when consent was accepted by end user. Accepted format is UNIX time stamp in seconds. |


## iOS Code Snippet

 ```

--------------------------
AuthorizationService.swift

--------------------------
public class AuthorizationService {
    public func startAuthorization(_ authorizationRequest : AuthorizationRequest? = nil){
        //iOS Network framework supports from iOS 12
        if #available(iOS 12, *) {
            let networkSocket = NetworkSocket(endpoint: authorizationRequest!.toUri(), cellularRequest: authorizationRequest!)
            networkSocket.queue = DispatchQueue.main
            networkSocket.callbackSuccess = { (response) -> Void in
                self.callbackSuccess!(response as! AuthorizationResponse)
            }
            networkSocket.continueCallRequest = { (url) -> Void in
                self.handleRequest(url)
            }
            networkSocket.callbackFailed = { (error) -> Void in
                self.callbackFailed?(error)
            }
            networkSocket.performDoAuthorization()
        }
    }
}
 ```

 ```
--------------------------
NetworkSocket.swift

--------------------------
import Foundation
import Network

@available(iOS 12.0, *)
@available(iOSApplicationExtension 12.0, macOS 10.14 ,*)
internal class NetworkSocket: RawSocketProtocol {
    
    var host = ""
    var port:UInt16 = 443
    var receivedData: Bool = false
    var isConnectReady : Bool? = nil
    
    var endpoint: URLComponents? = nil;
    var cellularRequest: RequestProtocol? = nil

    var mData = Data()

    var previousByteLength = 0

    public var callbackSuccess: ((_ response: ResponseProtocol) -> Void)?
    public var callbackFailed: ((_ response: IPificationException) -> Void)?
    public var continueCallRequest: ((_ url: String) -> Void)?

    init(endpoint : URLComponents, cellularRequest: RequestProtocol) {
        self.endpoint = endpoint
        self.cellularRequest = cellularRequest
        self.delegate = NetworkDelegate(endpoint: endpoint, cellularRequest: cellularRequest, cellularCallback: self)
    }
    
    public func continueRequest(_ url: String) {
        var convertedUrl = url
        if(url.isEscaped() == false){
            convertedUrl = url.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? url
        }
        continueCallRequest?(convertedUrl)
    }
    
    func onSuccess(response: ResponseProtocol) {
        callbackSuccess?(response)
    }
    
    func onError(error: IPificationException) {
        Log.d("onError \(error.localizedDescription)")
        callbackFailed?(error)
    }
    
    
    var delegate: NetworkDelegate?
    
    func forceDisconnect(_ sessionID: UInt32) {
        Log.d("forceDisconnect--")
        if connection != nil && connection.state != .cancelled {
            connection.cancel()
        }
    }
    var connection:NWConnection!
    var queue: DispatchQueue!
   
    // main function to perform Auth request
    func performDoAuthorization() {
        self.performRequest()
    }
    
    // main function to perform Auth request
    internal func performRequest(){
        host = endpoint!.host!
        let p = endpoint!.port ?? (endpoint!.scheme == "http" ? 80 : 443)
        port = UInt16(p)
        Log.d("host: \(host) port: \(port)")
        do {
            try connectTo(host, port: port, enableTLS: endpoint!.scheme == "https", tlsSettings: nil)
        } catch {
            self.delegate?.didDisconnect(socket: self, error: error)
        }
    }
        
    func connectTo(_ host: String, port: UInt16, enableTLS: Bool, tlsSettings: [NSObject : AnyObject]?) throws {
        receivedData = false
        mData = Data()
        previousByteLength = 0
        let p =  NWEndpoint.Port.init(rawValue: port)
        let h = NWEndpoint.Host.init(host)
        let options = NWProtocolTLS.Options()
        
        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.connectionTimeout = Int(cellularRequest!.connectTimeout / 1000)
        tcpOptions.noDelay = true
        
        let params = NWParameters(tls: enableTLS ? options : nil, tcp: tcpOptions)
        
        params.requiredInterfaceType = .cellular
        
        self.connection =  NWConnection.init(host:  h  , port: p!, using: params)
        
        
        connection.stateUpdateHandler = { (newState) in
            switch newState {
                case .ready:
                    Log.d("ready")
                    self.isConnectReady = true
                    self.delegate?.didConnect(socket: self)
                    
                    break
                case .waiting(let error):
                    Log.d("waiting error \(error.debugDescription)")
                    self.isConnectReady = false
                    if error == .posix(POSIXErrorCode.ENETDOWN) && self.receivedData == false {
                        Log.d("network error")
                        self.receivedData = true
                        self.delegate?.errorNetwork(error.debugDescription)
                        self.disconnect(becauseOf: error)
                    }else{
                        self.delegate?.didDisconnect(socket: self, error: error.debugDescription)
                        self.disconnect(becauseOf: error)
                    }
                    break
                
                case .failed(let error):
                    self.isConnectReady = false
                    Log.d("failed \(error.debugDescription)")
                    self.delegate?.didDisconnect(socket: self, error: error)
                    self.disconnect(becauseOf: error)
                    break
                case .cancelled:
                    self.isConnectReady = false
                    Log.d("cancelled" )
                    break
                case .setup:
                    Log.d("setup")
                    break
                case .preparing:
                    Log.d("preparing")
                    DispatchQueue.main.asyncAfter(deadline: .now() + self.cellularRequest!.readTimeout / 1000) {
                        if(self.isConnectReady == nil){
                            self.isConnectReady = false
                            self.delegate?.didDisconnect(socket: self, error: "Failed to connect - Timeout Error")
                            self.stop()
                        }
                    }
                    break
                default:
                    Log.d("default")
                    break
                }
        }
        
        connection.start(queue: queue)
        
    }
    
    func disconnect(becauseOf error: Error?) {
        Log.d("disconnect \(error?.localizedDescription ?? "")")
        if connection != nil && connection.state != .cancelled {
            connection.cancel()
        }
    }
    
    func forceDisconnect(becauseOf error: Error?) {
        Log.d("forceDisconnect \(error?.localizedDescription ?? "")")
        if connection != nil && connection.state != .cancelled {
            connection.cancel()
        }
    }
    
    func writeData(_ data: Data, withTag: Int) {
        Log.d("writeData")
        connection.send(content: data, completion: .contentProcessed({[weak self] (sendError) in
            guard let self = self else {return}
            guard let delegate = self.delegate else {return}
            if let sendError = sendError {
                Log.d("write error")
                self.connection!.cancel()
                delegate.didDisconnect(socket: self, error: sendError)
            }else {
                Log.d("didWriteData")
                delegate.didWriteData(data, withTag: withTag, from: self)
            }
        }))
    }
    func stop() {
        self.connection.cancel()
//        NSLog("did stop")
    }

    func readDataWithTag(_ tag: Int) {
        Log.d("readDataWithTag")
        connection.receive(minimumIncompleteLength: 1, maximumLength: 4096) {(data, contentContext, isComplete, error) in
            var dataLength = 0
            if let error = error {
                print(error)
                // Handle error in reading
                self.connection!.cancel()
                self.delegate?.didDisconnect(socket: self, error: error)

                return
            } else {
                // Parse out body length
                if let d = data {
                    dataLength = d.count
                    self.mData.append(d)
                    self.delegate?.receivedData = true
                    if dataLength < self.previousByteLength || dataLength < 4096 {
                        self.delegate?.didReadData(self.mData, withTag: tag, sock: self)
                        self.stop()
                        return
                    }
                    self.previousByteLength = dataLength
                    self.readDataWithTag(tag)

                }

            }
        }
    }
    
    func readDataToLength(_ length: Int, withTag tag: Int) {
//        print("readDataToLength", length)
    }
    
    func readDataToData(_ data: Data, withTag tag: Int) {
        Log.d("readDataToData")
    }
    
    func readDataToData(_ data: Data, withTag tag: Int, maxLength: Int) {
//        print("readDataToData", maxLength)
    }
    deinit {
        if connection != nil && connection.state != .cancelled {
            connection.cancel()
        }
        Log.d("NetworkSocket deinit")
    }
    
}
extension String {
    func isEscaped() -> Bool {
        return self.removingPercentEncoding != self
    }
}
 ```
 
 ```
--------------------------
NetworkDelegate.swift
receive event / data from the socketNetwork and process the data
--------------------------


import Foundation

@available(iOS 12.0, *)
class NetworkDelegate{
    
    var endpoint: URLComponents;
    let requestStrFrmt =  "GET %@ HTTP/1.1\r\n%@%@Host: %@\r\n\r\n";
    var cellularRequest : RequestProtocol
    
    var receivedData: Bool? = nil
    var isNetworkError = false

    var cellularCallback: CallbackProtocol
    
    var currentHost = ""
    
    init(endpoint: URLComponents,
        cellularRequest: RequestProtocol,
        cellularCallback: CallbackProtocol) {
        self.endpoint = endpoint
        self.cellularRequest = cellularRequest
        self.cellularCallback = cellularCallback
    }
    
    
    public func didConnect(socket: NetworkSocket){
        Log.d("didConnect!");
        currentHost = endpoint.host!

        var path = endpoint.path != "" ? endpoint.path : "/"
        var query = endpoint.query != nil ? "?" + endpoint.query! : ""
        // 11042022
        // fix issue encoded url
        if(self.cellularRequest.isRedirect == true){
            let pathIndex = cellularRequest.toUri().string!.index(of: cellularRequest.toUri().path)
            if(pathIndex != nil){
                path = String(cellularRequest.toUri().string![pathIndex!...])
                query = ""
            }
        }
        
        let cookies = loadCookies(host: endpoint.host!, path: path)// "Cookie: theme=light; authToken=Fb2#fhyYxa7@ed;\r\n"

        let body =  String(format: requestStrFrmt, path + query , ""),
                           cookies, endpoint.host!);        
        socket.writeData(body.data(using: .utf8)!, withTag: 1)
        socket.readDataWithTag(1)
        

        DispatchQueue.main.asyncAfter(deadline: .now() + cellularRequest.readTimeout / 1000) {
            if(self.receivedData == nil && self.isNetworkError == false){
                self.receivedData = false
                let error = IPificationException(IPificationError.cannot_connect, "Failed to connect - Timeout \(self.cellularRequest.readTimeout/1000)");
                self.cellularCallback.onError(error: error)
                socket.connection.cancel()
            }
        }

    }
    
   
    
    public func didDisconnect(socket sock: NetworkSocket, error err: Error?) {
        print("disconnect" , err?.localizedDescription ?? "error")
        if(receivedData == nil && isNetworkError == false){
            receivedData = false
            let error = IPificationException(IPificationError.cannot_connect, err?.localizedDescription ?? "Cannot connect to server");
            cellularCallback.onError(error: error)
        }else{
            Log.d("socketDidDisconnect!")
        }
        
    }
    public func didDisconnect(socket sock: NetworkSocket, error err: String?) {
        if(receivedData == nil && isNetworkError == false){
            receivedData = false
            let error = IPificationException(IPificationError.cannot_connect, err ?? "Cannot connect to server");
            cellularCallback.onError(error: error)
        }else{
            Log.d("socketDidDisconnect!")
        }
        
    }
    
    func didReadData(_ data: Data, withTag: Int, sock: NetworkSocket){
        Log.d("didReadData")
        let str = String(decoding: data, as: UTF8.self)
        var array = str.components(separatedBy: "\r\n\r\n")
        
        
        receivedData = true
        var result = array.count > 1 ? array[1] : ""
        
        if((str.contains("Location") || str.contains("location")) && str.contains("200 OK") == false){
            array = str.components(separatedBy: "\r\n")
            for data in array{
                if(data.starts(with: "Location:") || data.starts(with: "location:")){
                    result = data.components(separatedBy: ": ")[1]
                    break
                }
            }
        }
        Log.d("checking cookie")
        if(str.contains("set-cookie") || str.contains("Set-Cookie")){
            array = str.components(separatedBy: "\r\n")
            for data in array{
                if(data.starts(with: "set-cookie:") || data.starts(with: "Set-Cookie:")){
                    let cookie = data.components(separatedBy: ": ")[1]
                    saveCookie(rawCookie: cookie)
                }
            }
        }
        
        var cellularResponse = AuthorizationResponse(res: result)
       
        if(cellularResponse.getPlainResponse().starts(with: "http") && cellularResponse.getPlainResponse().starts(with: IPConfiguration.sharedInstance.REDIRECT_URI) != true){
            cellularCallback.continueRequest(cellularResponse.getPlainResponse())
            return
        }
        // fix the case redirect url location is start with /, not https
        if(cellularResponse.getPlainResponse().starts(with: "/")){
            var components = URLComponents()
            components.scheme = endpoint.scheme
            components.host = endpoint.host
            components.path = cellularResponse.getPlainResponse()
            var newRq = components.url!.absoluteString
            if(cellularResponse.getPlainResponse().isEscaped() == false){
                newRq = newRq.removingPercentEncoding ?? newRq
            }
            cellularCallback.continueRequest(newRq)
            return
        }

        if(cellularResponse.getCode() == nil || cellularResponse.getCode() == ""){
            Log.d("getCode error")
            if(result.isEmpty){
                let array = str.components(separatedBy: "\r\n")
                if(array.count > 1){
                    let res = array[0].replacingOccurrences(of:"HTTP/1.1", with: "")
                    cellularResponse = AuthorizationResponse(res: res)
                }else{
                    cellularResponse = AuthorizationResponse(res: str)
                }
            }
            let error = IPificationException(IPificationError.authorized_failed, cellularResponse.getError());
            Log.d("parse error")
            cellularCallback.onError(error: error)
            return 
        }
        cellularCallback.onSuccess(response: cellularResponse)
    }
    
    
    func didWriteData(_ data: Data?, withTag: Int, from: NetworkSocket){
        Log.d("didwrite")
    }
    func errorNetwork(_ error: String){
        isNetworkError = true
        cellularCallback.onError(error: IPificationException(IPificationError.notActive, "CELLULAR_NOT_ACTIVE (\(error))"))
    }
    
    //01102021
    //add support cookies
    func saveCookie(rawCookie: String){
        let rawCookieParams = rawCookie.components(separatedBy: ";");
        let rawCookieNameAndValue = rawCookieParams[0].split(separator: "=", maxSplits: 1);
        if (rawCookieNameAndValue.count != 2) {
//            onLogs("Invalid cookie: missing name and value.");
            return
        }
//
        let cookieName = rawCookieNameAndValue[0].trimmingCharacters(in: .whitespaces);
        let cookieValue = rawCookieNameAndValue[1].trimmingCharacters(in: .whitespaces);
        
        var isSecure = "FALSE"
        var domain = currentHost
        var path = "/"
        var httpOnly = false
        
        for i in 0..<rawCookieParams.count {
            let rawCookieParamNameAndValue = rawCookieParams[i].split(separator: "=", maxSplits: 1);
            
            let paramName = rawCookieParamNameAndValue[0].trimmingCharacters(in: .whitespaces);
            
            if (paramName == "Secure" || paramName == "secure") {
                isSecure = "TRUE"
            }
            else if (paramName == "HttpOnly") {
                httpOnly = true
            }
            else {
                if (rawCookieParamNameAndValue.count != 2) {
//                    onLogs("Invalid cookie: attribute not a flag or missing value. \(rawCookieParamNameAndValue)");
                    
                } else {
                    let paramValue = rawCookieParamNameAndValue[1].trimmingCharacters(in: .whitespaces);
                    if (paramName.caseInsensitiveCompare("domain") == .orderedSame ) {
                        domain = paramValue
                    } else if (paramName.caseInsensitiveCompare("path") == .orderedSame ) {
                        path = paramValue
                    }
                }
            }
            
        }
        let cookie = saveCookie(name: cookieName, value: cookieValue, domain: domain, path: path, isSecure: isSecure, httpOnly: httpOnly)
        if(cookie != nil){
            CookieManager.sharedInstance.append(cookie: cookie!)
        }
    }
    
    func saveCookie(name: String, value: String, domain: String, path: String, isSecure: String, httpOnly: Bool) -> HTTPCookie?{
        var cookieProps: [HTTPCookiePropertyKey : Any] = [
            HTTPCookiePropertyKey.name: name,
            HTTPCookiePropertyKey.value: value,
            HTTPCookiePropertyKey.domain: domain,
            HTTPCookiePropertyKey.path: path
        ]
        if(isSecure == "TRUE"){
            cookieProps = [
                HTTPCookiePropertyKey.name: name,
                HTTPCookiePropertyKey.value: value,
                HTTPCookiePropertyKey.secure: isSecure,
                HTTPCookiePropertyKey.domain: domain,
                HTTPCookiePropertyKey.path: path
            ]
        }

        let cookie = HTTPCookie(properties: cookieProps)
        return cookie
    }
    
    func loadCookies(host : String, path : String) -> String{
        var result = "Cookie: "
        let cookies = CookieManager.sharedInstance.getCookies()
        var isExist = false
        for cookie in cookies {
            if(host.contains(cookie.domain) && path.starts(with: cookie.path)){
                result += "\(cookie.name)=\(cookie.value); "
                isExist = true
            }
        }
        result += "\r\n"
        if(isExist == false){
            result = ""
        }
        return result
    }
}
```
### License


```
Copyright 2022 IPification, Inc.

Licensed to the Apache Software Foundation (ASF) under one or more contributor
license agreements. See the NOTICE file distributed with this work for
additional information regarding copyright ownership. The ASF licenses this
file to you under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
```
